
1：自我介绍
A：工作经历

      2016年5月份入职绿蜘蛛科技有限公司，这是一家从事公路货运物流的公司，公司有自己的线下物流公司。

      2015年平台1.0版本上线，将自营的物流公司搬到线上。以新疆为切入点，拓展其他的物流经纪人与物流司机。

      到目前为止，平台有新疆司机用户五六千人，平均每天四五十单。

      刚进公司，就努力了解公司的业务，很快就从事一些核心模块的编码工作，成为技术Leader。



B：近期项目

      绿蜘蛛物流平台，分为经纪人端和司机端。

      经济人端可以组建自己的车队，发布货源，让司机抢单或者主动派单给司机。

      司机端，承接货运信息。司机确认装货之后，司机可以收到一笔预付款，用于中途加油加气，购买轮胎等。

      司机可以在指定的加油加气门店，凭借绿蜘蛛会员信息，享受优惠在线加油加气服务，降低司机的货运成本。

     

C：优点长处

       踏实沉稳，很强的责任心。

       反思总结，经常在CSDN、微信公众号等渠道，发表文章，总结工作中的点点滴滴。



D：平时爱好

       喜欢安静，养花、养宠物、带女儿爬山，旅游……^_^



E： 离职原因，期望加入

       领导还是比较看重和培养我的，但是公司工作两边之后，我发现公司发展方便不明确，包括研发在内的各种制度和流程不规范。想换了平台，在给公司创造价值的同时，学习一下研发管理制度和流程，对自己以后的技术管理之路有很有帮助。您也看到了，我在工作的七八年时间内，换了好几份工作，这对自己的职业发展不太好，现在发现这是一个很大的问题。所以想找一个好的平台，沉淀几年。我非常喜欢公司的环境和发展，希望能给我这个机会，谢谢！



2：优秀开发人员，重要特质
A：好奇心，多问几个为什么

用到一个技术点，可以从下面几个方向深入挖掘：

(1)底层原理是什么

(2)为什么这样设计

(3)它还有什么用法

(4)别人是怎么使用的

这样就可以从深度上掌握一个知识点。

然后，还可以横向挖掘：

(1)具备类似作用的，还有哪些知识点

(2)它的父节点是什么

(3)它的子节点是什么

(4)它衍生出什么知识点

这样，就从宽度上了解了一个知识点。

经常这样做，就可以更好地积累、提升、系统化。

B：执行力

C：做一个熟悉业务的技术人员

3：自己的优点和缺点，举例说明
其实面试官问这个问题的时候根本不关心你的缺点和优点是什么？优点不加分，缺点不减分。他们要看的是你自己能不能自圆其说。

这个问题看似简单老套，回答起来可谓破绽百出。面试官最想知道的就是你的应变能力，他们会从你说的话里找出破绽，然后追根问底，直到你的防线被突破

当HR问你缺点，用意落脚点就俩字，真实。

它想印证你的简历有没有夸大其词的粉饰，甚至有没有造假，

你这个人是不是和简历呈现的那样，

你是不是可以不被我PASS，推荐进入下一个面试环节。

优点：踏实沉稳，经常反思总结

缺点：知识和技能。因为这两点改进空间大，速度快。

4：离职原因
其实现在公司的老板还是比较看好我的，从普通的开发人员提升到项目经理的位置，在这两年我也给公司创造了价值，

但是，工作流程不规范，公司未来发展方向不明确，想到一个好的平台，学习规范的流程制度，为公司创造价值的同时，提升自己的价值。

5：未来3-5年计划
之前几年，换了一些公司，现在想在某个领域内更多的专研，沉淀一下自己，在公司里面扎根发展几年。

6：举例，项目中的难点是什么，怎么解决的
A：新疆司机用户很多都没有智能机，无法使用APP，使用短信控制流程。
短信运营商：上下行，固定上行通道，支出维语
B：对接加油加气平台，对方下单，通知绿蜘蛛支付的时候，对方客户端提示超时。
因为绿蜘蛛接收订单支付通知，需要判断是否是否可以支付，拉取订单信息，保存订单信息，扣款等一些列逻辑，耗时比较长，而对方超时时间1s。
采用异步线程，处理订单业务逻辑。同步只返回司机是否可以支付。

7：项目中是怎么实现登录注册的
主要是想让你说怎么是实现登录安全的，包括数据在数据库如何存储，数据加密等
注册，前端密码md5加密，传输到后台。
登录除了验证账号和密码意外，还需要验证设备，是否是经常登录的设备，是否白名单设备。

8：mysql索引中使用的数据结构是什么
B+Tree

9：说一下连接池的实现，简单说下代码
数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。
我们可以通过设定连接池最大连接数来防止系统无尽的与数据库连接。
更为重要的是我们可以通过连接池的管理机制监视数据库的连接的数量﹑使用情况，为系统开发﹑测试及性能调整提供依据。
我们自己尝试开发一个连接池，来为上面的查询业务提供数据库连接服务：
① 编写class 实现DataSource 接口
② 在class构造器一次性创建10个连接，将连接保存LinkedList中
③ 实现getConnection 从 LinkedList中返回一个连接
④ 提供将连接放回连接池中方法

10：了解Mysql的行级锁么，说一下Innodb中的行级锁
LOCK IN SHARE MODE 会在读取的行上加共享锁,其他session只能读不能修改或删除，
FOR UPDATE 在读取行上设置一个排他锁 。阻止其他session读取或者写入行数据
这样看起来似乎就能解释为什么使用LOCK IN SHARE MODE 会产生死锁了，假如两个事务 A 、 B 都读取同一行记录，那么在这一行就加上了共享锁，但是 A 和B 事务中都需要修改这一行，那么都要等待对方释放共享锁才能进行，结果造成了死锁。
只能使用 for update 来防止死锁和重复插入。

11：数据库优化有哪些方面，怎么优化的
1、 表的设计要规范，即要符合数据库设计三范式。
2、 适当建立索引，在频繁作为检索条件，更新较少的字段上建立索引，以提高查询速度。
3、 分表查询，有水平分割、垂直分割。
4、 读写分离，读(read)、写(create、update、delete)。

12：Spring mvc的工作流程
1、请求httpServletRequest发送到DispatcherServlet。DispatcherServlet实际上就是获取了请求的Controller的路径
2、DispatcherServlet 到 HanderMapping
3、DispatcherServlet 到HandlerAdapter
4、HandlerAdapter 就管理Controller的处理过程，并获取到Controller的返回结果ModelAndView
5、HandlerAdapter将处理后的结果ModelAndView，返回给DispatcherServlet。
6、DispatcherServlet将调用视图解析器ViewResolver .
7、通过ViewResolver拼装了要返回的视图。
8、Dispatcher将拼装的视图，返回。

13：讲解一下你对IOC/DI/AOP的理解
AOP概述：
AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。
使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”
实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码

AOP使用场景：
Authentication 权限
Caching 缓存
Context passing 内容传递
Error handling 错误处理
Lazy loading　懒加载
Debugging　　调试
logging, tracing, profiling and monitoring　记录跟踪　优化　校准
Performance optimization　性能优化
Persistence　　持久化
Resource pooling　资源池
Synchronization　同步
Transactions 事务

AOP使用方法：
配置可以通过xml文件来进行，大概有四种方式：
1. 配置ProxyFactoryBean，显式地设置advisors, advice, target等
2. 配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象
3. 通过<aop:config>来配置
4. 通过<aop: aspectj-autoproxy>来配置，使用AspectJ的注解来标识通知及切入点
也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象

14：Java的GC机制
什么时候，对什么东西，做了什么事情。
程序员不能具体控制时间，系统在不可预测的时间调用System.gc()函数；
超出了作用域或引用计数为空的对象；从gc root开始搜索找不到的对象，而且经过一次标记、清理，仍然没有复活的对象。
删除不使用的对象，回收内存空间；运行默认的finalize,当然程序员想立刻调用就用dipose调用以释放资源如文件句柄，JVM用from survivor、to survivor对它进行标记清理，对象序列化后也可以使它复活。

GC的一些方法：
finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。
finalize()执行流程：
当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。
否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。
执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。
finalize()什么时候执行：
1.所有对象被Garbage Collection时自动调用,比如运行System.gc()的时候.
2.程序退出时为每个对象调用一次finalize方法。
3.显式的调用finalize方法

GC roots
GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
GC Root：
常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。
一个对象可以属于多个root，GC root有几下种：
A：Class - 由系统类加载器(system class loader)加载的对象
这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots。
B：Thread - 活着的线程
C：Stack Local - Java方法的local变量或参数
D：JNI Local - JNI方法的local变量或参数
E：JNI Global - 全局JNI引用
F：Monitor Used - 用于同步的监控对象
G：Held by JVM - 用于JVM特殊目的由GC保留的对象
但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。
然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。

15：Java final关键字有哪些用法 
A：final修饰变量，变成常量，不允许修改
B：final修饰类，不能被继承
C：final修饰方法，不能被重写
D：外部类调用内部类形参，如果形参被使用，必须用final修饰，保证数据一致性。

17：面向对象的五个基本原则
A:单一职责原则（SRP）
一个类应该仅有一个引起它变化的原因
比如在职员类里，将工程师、销售人员、销售经理这些情况都放在职员类里考虑，其结果将会非常混乱，在这个假设下，职员类里的每个方法都要if else判断是哪种情况，从类结构上来说将会十分臃肿，并且上述三种的职员类型，不论哪一种发生需求变化，都会改变职员类！这个是大家所不愿意看到的！

B:开放封闭原则（OCP）
既开放又封闭，对扩展是开放的，对更改是封闭的！
扩展即扩展现行的模块，当我们软件的实际应用发生改变时，出现新的需求，就需要我们对模块进行扩展，使其能够满足新的需求！
更改封闭即是在我们对模块进行扩展时，勿需对源有程序代码和DLL进行修改或重新编译文件！
这个原则对我们在设计类的时候很有帮助，坚持这个原则就必须尽量考虑接口封装，抽象机制和多态技术！

C:里氏替换原则（LSP）
子类可以替换父类并且出现在父类能够出现的任何地方
在这个原则中父类应尽可能使用接口或者抽象类来实现！

D:依赖倒置原则（DIP）
传统的结构化编程中，最上层的模块通常都要依赖下面的子模块来实现，也称为高层依赖低层！
所以DIP原则就是要逆转这种依赖关系，让高层模块不要依赖低层模块，所以称之为依赖倒置原则！

E:接口隔离原则（ISP）
这个原则的意思是：使用多个专门的接口比使用单个接口要好的多！
在我实际编程中，为了减少接口的定义，将许多类似的方法都放在一个接口中，
最后发现，维护和实现接口的时候花了太多精力，而接口所定义的操作相当于对客户端的一种承诺，
这种承诺当然是越少越好，越精练越好，过多的承诺带来的就是你的大量精力和时间去维护！

17：死锁产生的条件
什么是死锁： 

如果一个进程集合里面的每个进程都在等待这个集合中的其他一个进程（包括自身）才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁，处于死锁状态的进程称为死锁进程

死锁的原因：

A：因竞争资源发生死锁现象

 B：因竞争资源发生死锁现象

18：Java中如何检查线程死锁
A： Jconsole是JDK自带的图形化界面工具，使用JDK给我们的的工具JConsole

B：Jstack是JDK自带的命令行工具，主要用于线程Dump分析

19：用两个栈实现一个队列
拿到这种问题，我们首先应该思考这两种结构的特性是什么，为什么会出这样的题。其实就说明这两者的特性是有某种联系的，这么想的话其实很简单。
栈的最大特点就是先进后出，让我们用两个先进后出的栈来实现一个先进先出的队列，
那么我们把数据压入第一个栈，此时我们很清楚它的出战顺序是与我们想要的队列的出队顺序是相反的，
如果再把这个栈里面的元素依次压入第二个栈，此时我们想想栈2里面的元素的顺序，相当于对一组数据进行了两次倒序，此时对第二个栈进行的出栈操作的顺序就相当于这组数据进入队列的顺序了。
可以看看下面的图，假设现在入队的元素是1,2,3,4，那么入队之后处在队头的元素为1，队尾为4，那么我们想要通过s1和s2实现这样的队列。
00 基础篇 > 场景1 > image2018-4-2 17:28:18.png
接下来才是重点所在，我们要用这两个栈来实现一个队列，那么需要写出队列中的几个基本操作函数，如下所示

00 基础篇 > 场景1 > image2018-4-2 17:28:51.png
                      








