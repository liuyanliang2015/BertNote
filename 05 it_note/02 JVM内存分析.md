# JVM内存模型
![JVM内存模型](https://github.com/liuyanliang2015/BertNote/blob/master/pics/JVM.png)

> 内存泄漏与内存溢出的区别：<br>
> 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。<br>
> 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序<br>
> 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。

## 程序计数器
程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>

由于java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的线程计数器，每条线程之间计数器互不影响，独立存储，我们称这类内存为：线程私有内存。

这个区域是唯一一个没有内存溢出情况的区域，它的生命周期与线程相同。



## 虚拟机栈
与线程计数器一样，虚拟机栈也是线程私有的。<br>

每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。<br>

经常有人把Java内存划分为：堆内存(Heap)和栈内存(Stack)，这种分法是比较粗糙的，实际内存区域比这复杂的多。

## 本地方法栈
本地方法栈与虚拟机栈发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。这个区域具体的虚拟机可以自由实现，甚至有的虚拟机(例如Sun HotSpot)直接把本地方法栈和虚拟机栈合二为一。

## 堆
堆是java虚拟机管理内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。<br>

此区域唯一的目的就是存放对象实例。几乎所有对象实例都在这里分配内存，但不是绝对的。<br>

堆是垃圾收集的主要区域（"GC 堆"）。由于现在收集器基本上都是采用分代收集算法，所以java堆中还可以细分为：新生代(Eden、From Survivor、To Survivor)和老年代。<br>

根据Java虚拟机规范规定，Java堆可以处于不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是扩展的。不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果堆中没有内存来完成实例分配，而且堆也无法扩展时，将会抛出OutOfMemoryError异常。


## 方法区
方法区跟Java堆一样，是每个线程共享的内存区域，用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区当做是堆的一个逻辑部分，但是它还有一个别名叫Non-Heap(非堆)，目的应该是与堆区分开。


## 运行时常量池
运行时常量池是方法区的一部分。Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。

## 直接内存
在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。



## JVM案例
![JVM内存模型案例](https://github.com/liuyanliang2015/BertNote/blob/master/pics/JVM-demo.png)


![JVM内存模型案例](https://github.com/liuyanliang2015/BertNote/blob/master/pics/jvm-demo2.png)


![JVM内存模型案例](https://github.com/liuyanliang2015/BertNote/blob/master/pics/jvm-demo3.png)



## 线程可见性

每一个线程有一个工作内存和共享主内存。

工作内存存放主内存中变量的值的拷贝。

如果需要在其他线程中年立即可见，需要使用volatile关键字。

可见性： 一个线程修改了变量，其他线程可以立即知道。

### 保证可见性的方法：

A： volatile

B： synchronize（unlock之前，写变量值到主内存）

C： final(一旦初始化完成，其他线程就可见)




## linux查看内存情况
使用jmap -heap 线程id，查看堆内存配置 <br>
![linux查看堆配置](https://github.com/liuyanliang2015/BertNote/blob/master/pics/jmap-heap.png) <br>

使用jstat -gc 线程id  时间间隔，来查看GC情况 <br>
![linux查看GC情况](https://github.com/liuyanliang2015/BertNote/blob/master/pics/jstat-gc.png)




