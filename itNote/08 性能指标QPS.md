## 一：性能的关键指标
###系统吞吐量（Throughput）
吞吐量指单位时间内系统处理的请求数量，体现系统的整体处理能力。
###响应时间（系统延迟Latency）
请求的平均响应时间。

> 一般来说，一个系统的性能收到系统吞吐量和响应时间两个条件的约束，缺一不可。比如，我的系统可以顶得住一百万的并发，但是系统的延迟是2分钟以上，那么，这个一百万的负载毫无意义。系统延迟很短，但是吞吐量很低，同样没有意义。<br>
> • 吞吐量(Throughput)越大，系统延迟(Latency)越差。因为请求量过大，系统太繁忙，所以响应速度自然会低。<br>
• 系统延迟（Latency）越好，能支持的吞吐量（Throughput）就会越高。因为Latency短说明处理速度快，于是就可以处理更多的请求。<br>
###并发数
系统同时能够处理的请求数/事务数。
###QPS(TPS)
并发数/响应时间。<br>
整体来看QPS能够概括系统吞吐量和延迟两方面指标，因此也是系统最重要的指标之一。

## 二：服务化系统构成模式
![混合服务架构](https://github.com/liuyanliang2015/BertNote/blob/master/pics/mixed-service.png)

![混合服务架构消耗](https://github.com/liuyanliang2015/BertNote/blob/master/pics/mixed-service-cost.png)


当一个请求发过来之后，常规的这个请求会消耗一下资源：CPU（负责计算）、系统内存、网络链接等系统自身资源；如果我们的系统是基于Java的，那还涉及到JVM资源的占用，JVM的heap和stack资源，其中Heap是更重要的指标。如果在这个请求需要与DB有交互，在连接DB进行操作的过程中，会消耗系统的数据库链接池资源。对应的在DB侧，会消耗DB的计算资源，而DB的计算最重要的指标就是DB的响应时间和DB的连接数。

## 三：常见的系统优化方案
### 1：代码优化
####调用接口异步化
调用依赖服务时，采用异步并行的方式调用，将多个耗时的请求合并发出，可以降低很多无谓的等待时间。
####IO异步化缓存化
系统中最常用的文件io是记录日志，在记录日志的时候设置合适的日志缓存，并使用异步化的方式写入日志文件；在必要的地方记录日志，避免日志滥用，不仅对io造成压力，且会浪费系统硬盘空间，在一些极端情况下，会因为硬盘空间耗尽而导致系统吞吐量显著下降。
####API的request及response不使用过大的对象
过大的request和response会增加网络带宽的压力，且过大的字节传入容易造成数据丢失。
####适当使用缓存
####慎重使用线程
有人说，thread is evil，因为多线程瓶颈就在于互斥和同步的锁上，以及线程上下文切换的成本，怎么样的少用锁或不用锁是根本。另外在系统中使用线程池时，避免因为使用线程池模式和数量限制设置不当，而成为系统瓶颈。

### 2：数据库调优
####数据库的锁的方式
并发情况下，锁是非常非常影响性能的。各种隔离级别，行锁，表锁，页锁，读写锁，事务锁，以及各种写优先还是读优先机制。性能最高的是不要锁，所以，分库分表，冗余数据，减少一致性事务处理，可以有效地提高性能。
####使用索引
在读写数据的时候都需要在where条件中检查索引的使用。
####避免在SQL级的join操作
SQL中的join操作对索引的优化是个很复杂的问题，因为互联网的项目经常会发生变化，针对数据表的索引也会不断优化，如果使用join很可能会无法正确索引；且SQL级的索引的功能维护性也非常差。
####部分结果集
在查询上增加适当的limit
####不要select * 
而是明确指出各个字段，如果有多个表，一定要在字段名前加上表名，不要让引擎去算。
####不要用Having
因为其要遍历所有的记录。性能差得不能再差。
####尽可能地使用UNION ALL 取代 UNION
####索引不要过多

